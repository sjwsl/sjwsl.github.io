I"U<p><em>Effective STL</em> Reading Notes</p>

<h2 id="引言">引言</h2>

<p>STL 包括迭代器、容器、函数对象和算法。</p>

<p>迭代器分类</p>
<ul>
  <li>输入迭代器（input iterator）：只读，在每个被遍历到的位置只能读一次</li>
  <li>输出迭代器（output iterator）：只写，在每个被遍历到的位置只能写一次</li>
  <li>前向迭代器（forward iterator）：可重复读写，不支持 –</li>
  <li>双向迭代器（bidirectional iterator）：可重复读写，支持 –</li>
  <li>随机访问迭代器（random access iterator）：在双向迭代器的基础上，支持迭代器算术</li>
</ul>

<p>容器分类</p>
<ul>
  <li>标准序列容器：vector string deque list</li>
  <li>标准关联容器：set multiset map multimap</li>
  <li>非标准序列容器： slist（单向链表） rope</li>
  <li>非标准关联容器：hash_set hash_multiset hash_map hash_multimap</li>
  <li>标准的非 STL 容器：数组 bitset valarray stack queue priority_queue</li>
</ul>

<p>所有重载了<code class="language-plaintext highlighter-rouge">()</code>的类都称为一个<strong>函数子类（functor class）</strong>，这些类的实例称为<strong>函数对象（function object）</strong>或<strong>函数子（functor）</strong>。</p>

<p>当我们讨论 STL 时，要考虑 STL 的不同实现，以及不同编译器对 STL 的不同支持。</p>

<h2 id="容器">容器</h2>

<h3 id="第1条慎重选择容器类型">第1条：慎重选择容器类型</h3>

<ul>
  <li>是否有序</li>
  <li>所需迭代器类型</li>
  <li>是否必须为标准 C++ 的一部分</li>
  <li>数据的布局是否要兼容 C</li>
  <li>是否要避免使用引用计数</li>
  <li>是否需要事务语义</li>
</ul>

<p>按照数据存储方式，容器可以分为<strong>连续内存（contiguous-memory）</strong>和<strong>基于节点（node-based）</strong>的。</p>
<ul>
  <li>连续内存：vector string deque rope
元素被存储在一块或多块动态分配的内存中，每块内存有多个元素。当有元素删除或者插入，同一内存块的其他元素要移动。这种移动影响到效率和异常安全性。</li>
  <li>基于节点：list 关联容器
每一个动态分配的内存块中只存放一个元素，元素的插入和删除只影响指向节点的指针，而不影响节点本身的内容</li>
</ul>

<h3 id="第2条不要试图编写独立于容器类型的代码">第2条：不要试图编写独立于容器类型的代码</h3>

<p>不同的 STL 容器支持的操作差别很大，因此对容器的泛化一般来说是没有意义的。</p>

<p>考虑到有时候不可避免地要更换容器类型，可以简单地用 <code class="language-plaintext highlighter-rouge">typedef</code> 来进行词法（lexical）层面上的封装。</p>

<h3 id="第3条确保容器中的对象副本正确且高效">第3条：确保容器中的对象副本正确且高效</h3>

<p>不要尝试把派生类插入到基类容器中，否则在复制的过程中会导致<strong>剥离（slicing）</strong>，丢失派生类特有的所有信息。如果想这么做，应该构造一个存放智能指针的容器。</p>

<h3 id="第4条用empty而不是size0">第4条：用<code class="language-plaintext highlighter-rouge">empty()</code>而不是<code class="language-plaintext highlighter-rouge">size()==0</code></h3>

<p>只是因为一些 list 的实现中 <code class="language-plaintext highlighter-rouge">size()</code> 耗费线性时间</p>

<h3 id="第5条优先使用区间函数而不是多次使用单元素函数">第5条：优先使用区间函数而不是多次使用单元素函数</h3>

<p>给定两个 vector <code class="language-plaintext highlighter-rouge">v1</code> 和 <code class="language-plaintext highlighter-rouge">v2</code>，让 <code class="language-plaintext highlighter-rouge">v1</code> 等于 <code class="language-plaintext highlighter-rouge">v2</code> 的后半部分。</p>

<p>最差的循环写法</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">v1</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">v2</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">v2</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">iter</span> <span class="o">!=</span> <span class="n">v2</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">iter</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">v1</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>用 <code class="language-plaintext highlighter-rouge">std::copy</code> 的写法，本质上其实也是循环</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">v1</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">v2</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">v2</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">v2</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">back_inserter</span><span class="p">(</span><span class="n">v1</span><span class="p">));</span>
</code></pre></div></div>

<p>几乎所有的利用插入迭代器（<code class="language-plaintext highlighter-rouge">inserter</code>, <code class="language-plaintext highlighter-rouge">front_inserter</code>, <code class="language-plaintext highlighter-rouge">back_inserter</code>）的 <code class="language-plaintext highlighter-rouge">std::copy</code> 都可以用区间版本的 <code class="language-plaintext highlighter-rouge">insert</code> 代替。</p>

<p>用区间函数的写法</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">v1</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">v2</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">v2</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">v2</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</code></pre></div></div>

<p>使用区间函数可以使代码更清晰，且很多时候效率更高。</p>

<p><strong>常用的区间函数（<code class="language-plaintext highlighter-rouge">iterator</code> 指随机访问迭代器，<code class="language-plaintext highlighter-rouge">InputIterator</code> 接受除输出迭代器外的所有迭代器）</strong></p>
<ul>
  <li>区间构造函数</li>
</ul>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">container</span><span class="o">::</span><span class="n">container</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">begin</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">end</span><span class="p">);</span>
</code></pre></div></div>
<ul>
  <li>区间插入</li>
</ul>

<p>序列容器</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">container</span><span class="o">::</span><span class="n">insert</span><span class="p">(</span><span class="n">iterator</span> <span class="n">position</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">begin</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">end</span><span class="p">);</span>
</code></pre></div></div>
<p>关联容器的版本不用指定插入位置</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">container</span><span class="o">::</span><span class="n">insert</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">begin</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">end</span><span class="p">);</span>
</code></pre></div></div>
<ul>
  <li>区间删除</li>
</ul>

<p>序列容器，返回指向被删除元素的后一个元素</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">iterator</span> <span class="n">container</span><span class="o">::</span><span class="n">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">begin</span><span class="p">,</span> <span class="n">iterator</span> <span class="n">end</span><span class="p">);</span>
</code></pre></div></div>
<p>关联容器，标准提到如果如果也要返回后一个元素会带来不可接受的性能负担，因此为 void 函数=</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">container</span><span class="o">::</span><span class="n">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">begin</span><span class="p">,</span> <span class="n">iterator</span> <span class="n">end</span><span class="p">);</span>
</code></pre></div></div>
<ul>
  <li>区间赋值</li>
</ul>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">container</span><span class="o">::</span><span class="n">assign</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">begin</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">end</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="第6条小心c的分析机制">第6条：小心C++的分析机制</h3>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ifstream</span> <span class="nf">dataFile</span><span class="p">(</span><span class="s">"ints.data"</span><span class="p">);</span>
<span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">(</span><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">dataFile</span><span class="p">),</span> <span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span>
</code></pre></div></div>

<p>这段代码可以通过编译，但是什么也不会做。编译器会尽可能把语句解释为函数声明，因此上面本来想创建 list 的代码被解释为函数的声明。函数的返回值类型是 <code class="language-plaintext highlighter-rouge">list&lt;int&gt;</code>，第一个参数类型是 <code class="language-plaintext highlighter-rouge">istream_iteratot&lt;int&gt;</code>，名称是 dataFile。第二个参数类型是一个签名为<code class="language-plaintext highlighter-rouge">istream_iterator()</code>函数指针，没有名称。</p>

<p>解决方法是避免使用匿名对象</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">begin</span><span class="p">(</span><span class="n">dataFile</span><span class="p">);</span>
<span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">end</span><span class="p">;</span>
<span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="第7条容器析构时不负责-delete-存放的指针">第7条：容器析构时不负责 delete 存放的指针</h3>

<p>C++11 后，这条可以简单地用 <code class="language-plaintext highlighter-rouge">unique_ptr</code> 或 <code class="language-plaintext highlighter-rouge">shared_ptr</code> 避免。</p>

<h3 id="第8条不要创建-auto_ptr-的容器">第8条：不要创建 <code class="language-plaintext highlighter-rouge">auto_ptr</code> 的容器</h3>

<p>这条也是 C++11 之前的历史遗留问题。</p>

<h3 id="第9条选择删除元素的方法">第9条：选择删除元素的方法</h3>

<p>删除容器中所有值为 1963 的元素。</p>

<p>对于标准序列容器，最简单的写法是 erase-remove</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">c</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">remove</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">1963</span><span class="p">),</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</code></pre></div></div>

<p>对于 list，还有更简单的写法</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">c</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="mi">1963</span><span class="p">);</span>
</code></pre></div></div>

<p>对于标准关联容器，没有 <code class="language-plaintext highlighter-rouge">remove</code> 成员函数</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">c</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="mi">1963</span><span class="p">)</span>
</code></pre></div></div>

<p>有 <code class="language-plaintext highlighter-rouge">BadValue(int x)</code>，删除容器中所有的 bad value。</p>

<p>对于标准序列容器，简单地使用 <code class="language-plaintext highlighter-rouge">remove_if</code> 替换 <code class="language-plaintext highlighter-rouge">remove</code> 即可</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">c</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">remove_if</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">BadValue</span><span class="p">),</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
<span class="n">c</span><span class="p">.</span><span class="n">remove_if</span><span class="p">(</span><span class="n">BadValue</span><span class="p">);</span> <span class="c1">// list</span>
</code></pre></div></div>

<p>对于标准关联容器，可以用循环删除。下面是错误的写法</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">iter</span> <span class="o">!=</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">iter</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">BadValue</span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">))</span> <span class="n">c</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>错误的原因是 <code class="language-plaintext highlighter-rouge">c.erase(iter)</code> 后 <code class="language-plaintext highlighter-rouge">iter</code> 的值就无效了，<code class="language-plaintext highlighter-rouge">++iter</code> 就不会返回想要的结果。解决方案是在删除之前递增</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">iter</span> <span class="o">!=</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">BadValue</span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">))</span> <span class="n">c</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">iter</span><span class="o">++</span><span class="p">);</span>
    <span class="k">else</span> <span class="n">iter</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如果要在删除的同时做一些其他事情（比如写日志），序列容器就没法用 erase-remove 的写法了。之前的两种循环写法对于序列容器都是错误的，因为序列容器调用 <code class="language-plaintext highlighter-rouge">erase</code> 不仅会使删除的迭代器失效，这个位置之后的所有迭代器都会失效。解决方案是利用 <code class="language-plaintext highlighter-rouge">erase</code> 的返回值。</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">iter</span> <span class="o">!=</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">BadValue</span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// do something</span>
        <span class="n">iter</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="n">iter</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="第10条分配子allocator的约定和限制">第10条：分配子（allocator）的约定和限制</h3>

<h3 id="第11条自定义分配子的合理用法">第11条：自定义分配子的合理用法</h3>

<h3 id="第12条容器的线程安全性">第12条：容器的线程安全性</h3>

<p>STL 的所有容器都只保证多线程同时读是线程安全的。</p>

<h2 id="vector-和-string">vector 和 string</h2>

<h3 id="第13条优先使用-vector-和-string-而不是内建数组">第13条：优先使用 vector 和 string 而不是内建数组</h3>

<p>使用 vector 和 string 可以免除内存管理的烦恼</p>

<p>有一种情况下要注意 string 的使用。有的 string 实现用到了引用计数，在多线程下同步控制的消耗很大，这种情况下可以用 <code class="language-plaintext highlighter-rouge">vector&lt;char&gt;</code> 代替。</p>

<h3 id="第14条使用-reserve-来避免不必要的重新分配">第14条：使用 reserve 来避免不必要的重新分配</h3>

<p>vector 和 string 的容量会自动增长。当需要更多空间时，会重新分配一块大小为当前容量某个倍数的内存（大多数实现为 2 倍），然后把容器所有元素复制到新的内存，最后析构原内存中的对象并释放旧内存。需要注意的是，重新分配后容器原来所有的指针、迭代器、引用都会失效。</p>
:ET