---
# layout: post
title: MIT 6.824 Lab2
categories: 
    - Lab Report
tag:
    - "6.824"
    - Golang
    - Distributed Systems
    - Raft
---

This is the first in a series of labs in which you'll build a fault-tolerant key/value storage system. In this lab you'll implement Raft, a replicated state machine protocol.

[Lab Homepage](http://nil.csail.mit.edu/6.824/2020/labs/lab-raft.html)

[Raft paper](https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf)

[TA's Guide](https://thesquareplanet.com/blog/students-guide-to-raft/)

## Part 2A

### Goal

Implement Raft leader election and heartbeats (AppendEntries RPCs with no log entries)

### Overview

Part 2A 要求实现 Raft 协议的 Leader 选举和心跳，满足论文中提到的 Election Safety。

### State

在 Part 2A 中，每个 Raft peer 需要维护基本信息以及论文 Figure2 中提到的与投票相关的状态，另外 `mu` 用于并发控制、`state` 表示 peer 的身份、`signal` 用于重置 Election Timeout。

```go
const (
	Leader State = iota
	Candidate
	Follower
)

type Raft struct {
	mu          sync.Mutex          // Lock to protect shared access to this peer's state
	peers       []*labrpc.ClientEnd // RPC end points of all peers
	persister   *Persister          // Object to hold this peer's persisted state
	me          int                 // this peer's index into peers[]
	dead        int32               // set by Kill()
	currentTerm int
	votedFor    int
	state       State
	signal      chan bool
}
```

### Log

为了方便 debug，我用 `rf.Log()` 封装了 Go 语言的 `log` 模块。注意 Log 访问了可能修改的共享变量 `rf.state`，因此调用前要保证获取了 `mu`。

```go
func (rf *Raft) Log(format string, v ...interface{}) {
	var msg string
	if rf.state == Leader {
		msg = fmt.Sprintf("Leader %d ", rf.me)
	} else if rf.state == Candidate {
		msg = fmt.Sprintf("Candidate %d ", rf.me)
	} else if rf.state == Follower {
		msg = fmt.Sprintf("Follower %d ", rf.me)
	}
	msg += fmt.Sprintf("term %d: ", rf.currentTerm)
	msg += fmt.Sprintf(format, v...)
	log.Println(msg)
}
```

### Structure

#### Main Loop

我们用一个循环来表示一个 Raft peer 的基本工作机制

```go
func (rf *Raft) MainLoop() {
	for !rf.killed() {
		rf.Lock()
		state := rf.state
		rf.Unlock()
		switch state {
		case Leader:
			rf.AsLeader()
		case Candidate:
			rf.AsCandidate()
		case Follower:
			rf.AsFollower()
		}
	}
}
```

#### AsFollower

`AsFollower` 用于表示 Follower 的行为。首先随机一个 Election Timeout，在这段时间内如果没有收到心跳或投票，则变为 Candidate。

用 Go 中的 `select` 关键字和 `chan` 配合，可以表达这种逻辑。

```go
func (rf *Raft) AsFollower() {
	timeoutCh := make(chan bool)
	go func() {
		time.Sleep(RandMsBetween(MinElectionTimeout, MaxElectionTimeout))
		timeoutCh <- true
	}()
	select {
	case <-timeoutCh: // 超时
		rf.Lock()
		defer rf.Unlock()
		rf.BeCandidate()
	case <-rf.signal: // 收到心跳
	}
}
```

#### AsCandidate

`AsCandidate` 采用一样的结构，有三种情况

```go
select {
	case <-timeoutCh: // 超时
		rf.Lock()
		defer rf.Unlock()
		rf.Log("timeout")
		rf.BeCandidate()
	case <-rf.signal: // 收到更大 term 的 RPC
		rf.Lock()
		defer rf.Unlock()
		rf.BeFollower()
	case <-voteCh: // 竞选结束
		rf.Lock()
		defer rf.Unlock()
		rf.Log("win election")
		rf.Beleader()
	}
```

### RPC

Part 2A 涉及两个 RPC `AppendEntires` 和 `RequestVote`

