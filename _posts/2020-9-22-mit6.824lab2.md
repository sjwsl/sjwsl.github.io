---
# layout: post
title: MIT 6.824 Lab2
categories: 
    - Lab Report
tag:
    - "6.824"
    - Golang
    - Distributed Systems
    - Raft
---

This is the first in a series of labs in which you'll build a fault-tolerant key/value storage system. In this lab you'll implement Raft, a replicated state machine protocol.

[Lab Homepage](http://nil.csail.mit.edu/6.824/2020/labs/lab-raft.html)

[Raft paper](https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf)

[TA's Guide](https://thesquareplanet.com/blog/students-guide-to-raft/)

## Part 2A

### Goal

Implement Raft leader election and heartbeats (AppendEntries RPCs with no log entries)

### Overview

Part 2A 要求实现 Raft 协议的 Leader 选举和心跳，满足论文中提到的 Election Safety。

### State

每个 Raft peer 需要维护基本信息，论文 Figure2 中与投票相关的状态，另外 `mu` 用于并发控制、`state` 表示 peer 的身份、`signal` 用于重置 Election Timeout。

```go
const (
	Leader State = iota
	Candidate
	Follower
)

type Raft struct {
	mu        sync.Mutex          // Lock to protect shared access to this peer's state
	peers     []*labrpc.ClientEnd // RPC end points of all peers
	persister *Persister          // Object to hold this peer's persisted state
	me        int                 // this peer's index into peers[]
	dead      int32               // set by Kill()
	currentTerm int
	votedFor    int
	state       State
	signal chan bool
}
```

### Log

为了方便 debug，我用 `rf.Log()` 封装了 Go 语言的 `log` 模块。注意 Log 访问了可能修改的共享变量 `rf.state`，因此调用前要保证获取了 `mu`。

```go
func (rf *Raft) Log(format string, v ...interface{}) {
	var msg string
	if rf.state == Leader {
		msg = fmt.Sprintf("Leader %d ", rf.me)
	} else if rf.state == Candidate {
		msg = fmt.Sprintf("Candidate %d ", rf.me)
	} else if rf.state == Follower {
		msg = fmt.Sprintf("Follower %d ", rf.me)
	}
	msg += fmt.Sprintf("term %d: ", rf.currentTerm)
	msg += fmt.Sprintf(format, v...)
	log.Println(msg)
}
```

### Structure

首先设计我们

### RPC

Part 2A 涉及两个 RPC `AppendEntires` 和 `RequestVote`

